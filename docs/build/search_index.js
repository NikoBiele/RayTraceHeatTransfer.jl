var documenterSearchIndex = {"docs":
[{"location":"gettingstarted/#Installation","page":"Getting started","title":"Installation","text":"","category":"section"},{"location":"gettingstarted/","page":"Getting started","title":"Getting started","text":"To install the package, use the following command inside the Julia REPL:","category":"page"},{"location":"gettingstarted/","page":"Getting started","title":"Getting started","text":"using Pkg\nPkg.add(\"RayTraceHeatTransfer\")","category":"page"},{"location":"gettingstarted/","page":"Getting started","title":"Getting started","text":"To load the package, use the command","category":"page"},{"location":"gettingstarted/","page":"Getting started","title":"Getting started","text":"using RayTraceHeatTransfer","category":"page"},{"location":"gettingstarted/#Enabling-multithreading-on-the-CPU","page":"Getting started","title":"Enabling multithreading on the CPU","text":"","category":"section"},{"location":"gettingstarted/","page":"Getting started","title":"Getting started","text":"When performing Monte Carlo ray tracing it is advantageous to use multithreading.","category":"page"},{"location":"gettingstarted/","page":"Getting started","title":"Getting started","text":"If using VSCode, enable CPU multithreading by setting the following in settings.json:","category":"page"},{"location":"gettingstarted/","page":"Getting started","title":"Getting started","text":"  \"julia.NumThreads\": 16,","category":"page"},{"location":"gettingstarted/","page":"Getting started","title":"Getting started","text":"Instead of 16, choose the number you prefer.","category":"page"},{"location":"gettingstarted/","page":"Getting started","title":"Getting started","text":"If you're using Jupyter notebook run:","category":"page"},{"location":"gettingstarted/","page":"Getting started","title":"Getting started","text":"using IJulia\nIJulia.installkernel(\"Julia 16 Threads\", env=Dict(\n    \"JULIA_NUM_THREADS\" => \"16\",\n))","category":"page"},{"location":"gettingstarted/","page":"Getting started","title":"Getting started","text":"To confirm that the number of available threads correspond to the desired number run:","category":"page"},{"location":"gettingstarted/","page":"Getting started","title":"Getting started","text":"julia> Threads.nthreads()","category":"page"},{"location":"description/#RayTraceHeatTransfer.jl-Documentation","page":"RayTraceHeatTransfer.jl Documentation","title":"RayTraceHeatTransfer.jl Documentation","text":"","category":"section"},{"location":"description/","page":"RayTraceHeatTransfer.jl Documentation","title":"RayTraceHeatTransfer.jl Documentation","text":"Radiative heat transfer in participating media","category":"page"},{"location":"description/#Description","page":"RayTraceHeatTransfer.jl Documentation","title":"Description","text":"","category":"section"},{"location":"description/","page":"RayTraceHeatTransfer.jl Documentation","title":"RayTraceHeatTransfer.jl Documentation","text":"This Julia package can be used for radiation heat transfer calculations in an enclosure with partly or fully reflecting walls containing an absorbing-emitting-scattering participating medium. This phenomenon is governed by the Radiative Transfer Equation (RTE), which is a integro-differential equation:","category":"page"},{"location":"description/","page":"RayTraceHeatTransfer.jl Documentation","title":"RayTraceHeatTransfer.jl Documentation","text":"fracpartial I_lambda(SOmega)partial S = kappa_lambda I_lambda mathrmb(S) - kappa_lambda I_lambda(SOmega) - sigma_mathrmslambda I_lambda(SOmega) + fracsigma_mathrmslambda4 pi int_Omega_i=4 pi I_lambda(SOmega_i) Phi_lambda(Omega_iOmega) dOmega_i","category":"page"},{"location":"description/","page":"RayTraceHeatTransfer.jl Documentation","title":"RayTraceHeatTransfer.jl Documentation","text":"Analytical solution of the RTE is only possible in simple cases. This repository contains a number of types and functions which collectively enables the user to build, mesh and ray trace a user defined 2D geometry to solve the RTE. The result of the ray tracing is four 'Exchange Factor' matrices which together describe how the enclosure is radiatively connected. Using the exchange factor matrices it is possible to quickly perform a heat transfer calculation on the entire enclosure, which would otherwise be computationally expensive to ray trace.","category":"page"},{"location":"description/#Features","page":"RayTraceHeatTransfer.jl Documentation","title":"Features","text":"","category":"section"},{"location":"description/","page":"RayTraceHeatTransfer.jl Documentation","title":"RayTraceHeatTransfer.jl Documentation","text":"Define a custom 2D geometry in a modular and interactive way.\nMesh the user defined geometry.\nRay trace the meshed geometry in parallel.\nSave and load ray tracing results as Exchange Factor matrices in CSV-format.\nQuickly calculate heat transfer in the geometry using the Exchange Factors.\nAvoid ray tracing the same geometry multiple times when changing boundary conditions.","category":"page"},{"location":"description/#Limitations","page":"RayTraceHeatTransfer.jl Documentation","title":"Limitations","text":"","category":"section"},{"location":"description/","page":"RayTraceHeatTransfer.jl Documentation","title":"RayTraceHeatTransfer.jl Documentation","text":"This package is limited to:","category":"page"},{"location":"description/","page":"RayTraceHeatTransfer.jl Documentation","title":"RayTraceHeatTransfer.jl Documentation","text":"A uniformly distributed gray participating medium.\nDiffuse surface emission/reflection.","category":"page"},{"location":"geometry/#Generate-and-mesh-geometry","page":"Generate and mesh geometry","title":"Generate and mesh geometry","text":"","category":"section"},{"location":"geometry/","page":"Generate and mesh geometry","title":"Generate and mesh geometry","text":"In this section it will be shown how to build geometries using this package.","category":"page"},{"location":"geometry/","page":"Generate and mesh geometry","title":"Generate and mesh geometry","text":"We start by importing the package","category":"page"},{"location":"geometry/","page":"Generate and mesh geometry","title":"Generate and mesh geometry","text":"using RayTraceHeatTransfer","category":"page"},{"location":"geometry/","page":"Generate and mesh geometry","title":"Generate and mesh geometry","text":"The geometry is built by a number of non-overlapping convex \"SubEnclosures\". The \"SubEnclosures\" always consist of four bounding points and they should always be convex (no internal angles above 180Â°). Non-convex shapes should be split into smaller convex \"SubEnclosures\". The reason that the \"SubEnclosures\" should be convex is that it makes the ray tracing more efficient. Here we define a 1x1 square (a single sub-enclosure).","category":"page"},{"location":"geometry/","page":"Generate and mesh geometry","title":"Generate and mesh geometry","text":"We start by defining an empty vector of \"SubEnclosures\".","category":"page"},{"location":"geometry/","page":"Generate and mesh geometry","title":"Generate and mesh geometry","text":"subs = SubEnclosure[]","category":"page"},{"location":"geometry/","page":"Generate and mesh geometry","title":"Generate and mesh geometry","text":"Now we can make one SubEnclosure at a time and push it into the vector. When specifying a SubEnclosure the inputs are as follows: The first four inputs are the bounding points, going in the counter clockwise direction. The next four inputs specifies whether the walls are solid or empty, which is important when connecting more SubEnclosures. The outer wall should always be solid for the ray tracing to work. The first wall is between point1 and point2 and so on, and the last wall is between point4 and point1.","category":"page"},{"location":"geometry/","page":"Generate and mesh geometry","title":"Generate and mesh geometry","text":"sub1 = SubEnclosure([0.0, 0.0],[1.0, 0.0],[1.0, 1.0],[0.0, 1.0],true,true,true,true)\npush!(subs, sub1)","category":"page"},{"location":"geometry/","page":"Generate and mesh geometry","title":"Generate and mesh geometry","text":"After adding a sub it is recommended to always ensure that it was correctly added. This can be done using the 'displayGeometry' function, which plots any number of SubEnclosures stored in a vector.","category":"page"},{"location":"geometry/","page":"Generate and mesh geometry","title":"Generate and mesh geometry","text":"displayGeometry(subs)","category":"page"},{"location":"geometry/","page":"Generate and mesh geometry","title":"Generate and mesh geometry","text":"(Image: plot)","category":"page"},{"location":"geometry/","page":"Generate and mesh geometry","title":"Generate and mesh geometry","text":"If the last added SubEnclosure is not satisfactory we can remove it and try again.","category":"page"},{"location":"geometry/","page":"Generate and mesh geometry","title":"Generate and mesh geometry","text":"pop!(subs)","category":"page"},{"location":"geometry/","page":"Generate and mesh geometry","title":"Generate and mesh geometry","text":"Then we can keep adding SubEnclosures to our geometry (and popping if we're not satisfied). It is recommended to display the geometry after each added subEnclosure.","category":"page"},{"location":"geometry/","page":"Generate and mesh geometry","title":"Generate and mesh geometry","text":"sub1 = SubEnclosure([0.0, 0.0],[1.0, 0.0],[2.0, 1.0],[0.0, 1.0],true,true,false,true)\npush!(subs, sub1)\ndisplayGeometry(subs)\n\nsub2 = SubEnclosure([0.0, 1.0],[2.0, 1.0],[1.0, 2.0],[-0.5, 1.5],false,true,false,true)\npush!(subs, sub2)\ndisplayGeometry(subs)\n\nsub3 = SubEnclosure([-0.5, 1.5],[1.0, 2.0],[1.0, 3.0],[-1.0, 4.0],false,true,false,true)\npush!(subs, sub3)\ndisplayGeometry(subs)\n\nsub4 = SubEnclosure([-1.0, 4.0],[1.0, 3.0],[4.0, 3.0],[4.0, 4.0],false,true,true,true)\npush!(subs, sub4)\ndisplayGeometry(subs)","category":"page"},{"location":"geometry/","page":"Generate and mesh geometry","title":"Generate and mesh geometry","text":"Viewing the final result. Notice that the subEnclosures are numbered incrementally and internal faces are shown as 'empty' while the outer surfaces are 'solid'. This will be important for defining boundary conditions when calculating heat transfer.","category":"page"},{"location":"geometry/","page":"Generate and mesh geometry","title":"Generate and mesh geometry","text":"(Image: plot)","category":"page"},{"location":"geometry/","page":"Generate and mesh geometry","title":"Generate and mesh geometry","text":"When we are finally satisfied with our geometry we can move on to meshing it. The fineness of the meshing decides the resolution of or our heat transfer calculations. We specifiy the number of splits in each SubEnclosure. In this case each SubEnclosure will be split into 11x11 cells.","category":"page"},{"location":"geometry/","page":"Generate and mesh geometry","title":"Generate and mesh geometry","text":"Ndim = 11","category":"page"},{"location":"geometry/","page":"Generate and mesh geometry","title":"Generate and mesh geometry","text":"Now we are ready to mesh the geometry. This is achieved by creating an instance of the RayTracingMesh type. The function which generates this type takes as input a vector of SubEnclosures and the number of splits.","category":"page"},{"location":"geometry/","page":"Generate and mesh geometry","title":"Generate and mesh geometry","text":"mesh1 = RayTracingMesh(subs,Ndim);\ndisplayMesh(mesh1)","category":"page"},{"location":"geometry/","page":"Generate and mesh geometry","title":"Generate and mesh geometry","text":"(Image: plot)","category":"page"},{"location":"geometry/","page":"Generate and mesh geometry","title":"Generate and mesh geometry","text":"Now that the geometry has been meshed we're ready to ray trace it.","category":"page"},{"location":"code/#Public-and-private-types-and-functions","page":"Code","title":"Public and private types and functions","text":"","category":"section"},{"location":"code/#Public-functions-and-types-for-geometry-creation","page":"Code","title":"Public functions and types for geometry creation","text":"","category":"section"},{"location":"code/","page":"Code","title":"Code","text":"CurrentModule = RayTraceHeatTransfer","category":"page"},{"location":"code/","page":"Code","title":"Code","text":"Geometry.SubEnclosure","category":"page"},{"location":"code/#Main.RayTraceHeatTransfer.Geometry.SubEnclosure","page":"Code","title":"Main.RayTraceHeatTransfer.Geometry.SubEnclosure","text":"SubEnclosure\n\nThis struct is used for initial geometry building. To Initialize it use: SubEnclosure(point1::Vector{Float64},point2::Vector{Float64},                 point3::Vector{Float64},point4::Vector{Float64},                 solidWall1::Bool,solidWall2::Bool,                 solidWall3::Bool,solidWall4::Bool) The first four inputs are the bounding points. The next four inputs state whether the walls are solid or empty.\n\n\n\n\n\n","category":"type"},{"location":"code/","page":"Code","title":"Code","text":"Geometry.displayGeometry(geometry::Vector{SubEnclosure})","category":"page"},{"location":"code/#Main.RayTraceHeatTransfer.Geometry.displayGeometry-Tuple{Vector{SubEnclosure}}","page":"Code","title":"Main.RayTraceHeatTransfer.Geometry.displayGeometry","text":"displayGeometry(geometry::Vector{SubEnclosure})\n\nThis function plots one or more SubEnclosures. It is used for building and validating the geometry. It automatically shows which walls are solid and empty, and shows the number of each SubEnclosure. This information is important when defining boundary conditions when solving heat transfer problems.\n\n\n\n\n\n","category":"method"},{"location":"code/","page":"Code","title":"Code","text":"Geometry.meshGeometry(subs::Vector{SubEnclosure},Ny::Int64,Nx::Int64) ","category":"page"},{"location":"code/#Main.RayTraceHeatTransfer.Geometry.meshGeometry-Tuple{Vector{SubEnclosure}, Int64, Int64}","page":"Code","title":"Main.RayTraceHeatTransfer.Geometry.meshGeometry","text":"meshGeometry(subs::Vector{SubEnclosure},Ny::Int64,Nx::Int64)\n\nThis function divides the geometry (any number of SubEnclosures) into a 2D computational mesh over which the ray tracing is performed.\n\n\n\n\n\n","category":"method"},{"location":"code/","page":"Code","title":"Code","text":"Geometry.RayTracingMesh","category":"page"},{"location":"code/#Main.RayTraceHeatTransfer.Geometry.RayTracingMesh","page":"Code","title":"Main.RayTraceHeatTransfer.Geometry.RayTracingMesh","text":"RayTracingMesh\n\nThis struct generates the mesh from a vector of SubEnclosures when instantiated.\n\n\n\n\n\n","category":"type"},{"location":"code/","page":"Code","title":"Code","text":"Geometry.displayMesh(mesh::RayTracingMesh)","category":"page"},{"location":"code/#Main.RayTraceHeatTransfer.Geometry.displayMesh-Tuple{RayTracingMesh}","page":"Code","title":"Main.RayTraceHeatTransfer.Geometry.displayMesh","text":"displayMesh(mesh::RayTracingMesh)\n\nThis function plots the mesh stored in a RayTracingMesh struct.\n\n\n\n\n\n","category":"method"},{"location":"code/","page":"Code","title":"Code","text":"Geometry.GasProperties","category":"page"},{"location":"code/#Main.RayTraceHeatTransfer.Geometry.GasProperties","page":"Code","title":"Main.RayTraceHeatTransfer.Geometry.GasProperties","text":"GasProperties\n\nThis struct holds information about the radiative properties of the participating medium.\n\n\n\n\n\n","category":"type"},{"location":"code/#Public-functions-for-ray-tracing","page":"Code","title":"Public functions for ray tracing","text":"","category":"section"},{"location":"code/","page":"Code","title":"Code","text":"RayTracing.sampleDomain(mesh::RayTracingMesh,gas::GasProperties,\n                N_rays::Int64,nthreads::Int64,displayWhileTracing::Bool)","category":"page"},{"location":"code/#Main.RayTraceHeatTransfer.RayTracing.sampleDomain-Tuple{RayTracingMesh, GasProperties, Int64, Int64, Bool}","page":"Code","title":"Main.RayTraceHeatTransfer.RayTracing.sampleDomain","text":"sampleDomain(mesh::RayTracingMesh,gas::GasProperties,\n            N_rays::Int64,nthreads::Int64,displayWhileTracing::Bool)\n\nThis function ray traces the entire domain, both surfaces and volumes.\n\n\n\n\n\n","category":"method"},{"location":"code/","page":"Code","title":"Code","text":"RayTracing.writeMatricesToCSV(FSS::Matrix{Float64},FSG::Matrix{Float64},\n                        FGS::Matrix{Float64},FGG::Matrix{Float64},\n                        mesh::RayTracingMesh,gas::GasProperties,\n                        N_rays::Int64)","category":"page"},{"location":"code/#Main.RayTraceHeatTransfer.RayTracing.writeMatricesToCSV-Tuple{Matrix{Float64}, Matrix{Float64}, Matrix{Float64}, Matrix{Float64}, RayTracingMesh, GasProperties, Int64}","page":"Code","title":"Main.RayTraceHeatTransfer.RayTracing.writeMatricesToCSV","text":"writeMatricesToCSV(FSS::Matrix{Float64},FSG::Matrix{Float64},\n                    FGS::Matrix{Float64},FGG::Matrix{Float64},\n                    mesh::RayTracingMesh,gas::GasProperties,\n                    N_rays::Int64)\n\nThis function saves the results of a ray tracing run, which gives four exchange factor matrices. These matrices are saved as CSV-files where the name gives information on the settings that were used to statistically measure them.\n\n\n\n\n\n","category":"method"},{"location":"code/#Public-functions-for-heat-transfer-calculation","page":"Code","title":"Public functions for heat transfer calculation","text":"","category":"section"},{"location":"code/","page":"Code","title":"Code","text":"HeatTransfer.readMatricesFromCSV(N_subs::Int64,Ndim::Int64,kappa::Float64,\n                            sigma_s::Float64,N_rays::Int64)","category":"page"},{"location":"code/#Main.RayTraceHeatTransfer.HeatTransfer.readMatricesFromCSV-Tuple{Int64, Int64, Float64, Float64, Int64}","page":"Code","title":"Main.RayTraceHeatTransfer.HeatTransfer.readMatricesFromCSV","text":"readMatricesFromCSV(N_subs::Int64,Ndim::Int64,kappa::Float64,\n                        sigma_s::Float64,N_rays::Int64)\n\nThis function reads 4 exchange factor matrices from CSV-files. These files can be generated with the 'writeMatricesToCSV'-function.\n\n\n\n\n\n","category":"method"},{"location":"code/","page":"Code","title":"Code","text":"HeatTransfer.steadyState(mesh::RayTracingMesh,FSS::Matrix{Float64},FSG::Matrix{Float64},\n                    FGS::Matrix{Float64},FGG::Matrix{Float64},\n                    epsw_in::Matrix{Float64},gas::GasProperties,\n                    Tw_in::Matrix{Float64},Tg_in::Vector{Float64},\n                    qw_in::Matrix{Float64},qg_in::Vector{Float64})","category":"page"},{"location":"code/#Main.RayTraceHeatTransfer.HeatTransfer.steadyState-Tuple{RayTracingMesh, Matrix{Float64}, Matrix{Float64}, Matrix{Float64}, Matrix{Float64}, Matrix{Float64}, GasProperties, Matrix{Float64}, Vector{Float64}, Matrix{Float64}, Vector{Float64}}","page":"Code","title":"Main.RayTraceHeatTransfer.HeatTransfer.steadyState","text":"steadyState(mesh::RayTracingMesh,FSS::Matrix{Float64},FSG::Matrix{Float64},\n                    FGS::Matrix{Float64},FGG::Matrix{Float64},\n                    epsw_in::Matrix{Float64},gas::GasProperties,\n                    maxIter::Int64,relTol::Float64,Tw_in::Matrix{Float64},\n                    Tg_in::Vector{Float64},qw_in::Matrix{Float64},qg_in::Vector{Float64})\n\nThis function obtains the steady state temperature distribution in a rigorous way.\n\n\n\n\n\n","category":"method"},{"location":"code/","page":"Code","title":"Code","text":"HeatTransfer.plotTemperatureField(mesh::RayTracingMesh,Tg::Vector{Float64},Tw=nothing)","category":"page"},{"location":"code/#Main.RayTraceHeatTransfer.HeatTransfer.plotTemperatureField","page":"Code","title":"Main.RayTraceHeatTransfer.HeatTransfer.plotTemperatureField","text":"plotTemperatureField(mesh::RayTracingMesh,Tg::Vector{Float64},Tw=nothing)\n\nThis function enables contour-like plots of custom geometries. It plots the gas temperature distribution and optionally also wall temperatures. The two temperature input vectors are returned by the function 'steadyState'. The wall temperature vector 'Tw' is optional.\n\n\n\n\n\n","category":"function"},{"location":"code/","page":"Code","title":"Code","text":"HeatTransfer.validCrosbieSchrenker(N_rays_tot::Int64,Ndim::Int64,Tw_hot::Float64)","category":"page"},{"location":"code/#Main.RayTraceHeatTransfer.HeatTransfer.validCrosbieSchrenker-Tuple{Int64, Int64, Float64}","page":"Code","title":"Main.RayTraceHeatTransfer.HeatTransfer.validCrosbieSchrenker","text":"validCrosbieSchrenker(N_rays_tot::Int64,Ndim::Int64,Tw_hot::Float64)\n\nThis function performs a comparison of the ray tracing result in a square with the analytical 2D solution tabulated by Crosbie & Schrenker (1982).\n\n\n\n\n\n","category":"method"},{"location":"code/#Public-utility-3D-view-factor-function","page":"Code","title":"Public utility 3D view factor function","text":"","category":"section"},{"location":"code/","page":"Code","title":"Code","text":"ViewFactor3D.viewFactor(POLY_A::Matrix{Float64}, POLY_B::Matrix{Float64})","category":"page"},{"location":"code/#Main.RayTraceHeatTransfer.ViewFactor3D.viewFactor-Tuple{Matrix{Float64}, Matrix{Float64}}","page":"Code","title":"Main.RayTraceHeatTransfer.ViewFactor3D.viewFactor","text":"viewFactor(POLY_A::Matrix{Float64}, POLY_B::Matrix{Float64})\n\nOriginal authors: Jacob A. Kerkhoff and Michael J. Wagner (MATLAB-implementation) University of Wisconsin-Madison, Energy Systems Optimization Lab https://github.com/uw-esolab/docs/tree/main/tools/viewfactor Originally written for the paper: \"A Flexible Thermal Model for Solar Cavity Receivers Using Analytical View Factors\" https://doi.org/10.1115/ES2021-63810\n\nTranslated to the Julia Programming Language by: Nikolaj Maack Bielefeld during studies at Aalborg University, Thermal Energy and Process Engineering. The ray tracing part of the original function was not translated. Published in RayTraceHeatTransfer.jl with permission from the original authors.\n\nAnalytical solution derivation: Narayanaswamy, Arvind. \"An analytic expression for radiation view  factor between two arbitrarily oriented planar polygons.\" International Journal of Heat and Mass Transfer 91 (2015): 841-847.\n\nviewFactor(POLYA, POLYB) analytically computes the view factor from POLYA to POLYB and from POLYB to POLYA. Input arguments are in the form of 3x2 or Nx3 arrays, where each row corresponds to a vertex of the polygon, the columns refer to the X,Y,Z coordinates of the vertices. If Z coordinates are omitted, they are assumed to be zero.\n\nThe following must be true for both polygons:\n\npolygons are planar (all vertices lie in the same plane)\npolygons are simple (no self-intersecting polygons)\npolygons are convex (in theory, concave polygons should work, but  this remains untested)\n\n\n\n\n\n","category":"method"},{"location":"code/#Private-functions","page":"Code","title":"Private functions","text":"","category":"section"},{"location":"code/#Private-geometry-functions","page":"Code","title":"Private geometry functions","text":"","category":"section"},{"location":"code/","page":"Code","title":"Code","text":"Geometry.areaVolumeMesh(Nx::Int64,Ny::Int64,N_subs::Int64,\n            point1::Matrix{SVector{2,Float64}},point2::Matrix{SVector{2,Float64}},\n            point3::Matrix{SVector{2,Float64}},point4::Matrix{SVector{2,Float64}})","category":"page"},{"location":"code/#Main.RayTraceHeatTransfer.Geometry.areaVolumeMesh-Tuple{Int64, Int64, Int64, Vararg{Matrix{SVector{2, Float64}}, 4}}","page":"Code","title":"Main.RayTraceHeatTransfer.Geometry.areaVolumeMesh","text":"areaVolumeMesh(Nx::Int64,Ny::Int64,N_subs::Int64,\n            point1::Matrix{SVector{2,Float64}},point2::Matrix{SVector{2,Float64}},\n            point3::Matrix{SVector{2,Float64}},point4::Matrix{SVector{2,Float64}})\n\nThis function is called internallly inside the RayTracingMesh struct when generating a new instance. This function calculates the area of bounding walls and the volume of volumes.\n\n\n\n\n\n","category":"method"},{"location":"code/","page":"Code","title":"Code","text":"Geometry.defineSolidWalls(subs::Vector{SubEnclosure})","category":"page"},{"location":"code/#Main.RayTraceHeatTransfer.Geometry.defineSolidWalls-Tuple{Vector{SubEnclosure}}","page":"Code","title":"Main.RayTraceHeatTransfer.Geometry.defineSolidWalls","text":"defineSolidWalls(subs::Vector{SubEnclosure})\n\nThis function defines the solid walls of the mesh based on the user inputs for each SubEnclosure.\n\n\n\n\n\n","category":"method"},{"location":"code/","page":"Code","title":"Code","text":"Geometry.localWalls(point1::Vector{Float64},point2::Vector{Float64},\n                point3::Vector{Float64},point4::Vector{Float64})","category":"page"},{"location":"code/#Main.RayTraceHeatTransfer.Geometry.localWalls-NTuple{4, Vector{Float64}}","page":"Code","title":"Main.RayTraceHeatTransfer.Geometry.localWalls","text":"localWalls(point1::Vector{Float64},point2::Vector{Float64},\n            point3::Vector{Float64},point4::Vector{Float64})\n\nThis function determines a point on each wall of the current cell as well as an inward pointing normal vector of each wall. This information fully describe the walls of each cell.\n\n\n\n\n\n","category":"method"},{"location":"code/#Private-functions-for-ray-tracing","page":"Code","title":"Private functions for ray tracing","text":"","category":"section"},{"location":"code/","page":"Code","title":"Code","text":"RayTracing.coefs_exchange(mesh::RayTracingMesh, Wall_absorbX::Array{Float64, 3},\n                        Wall_absorbY::Array{Float64, 3},\n                        N_abs_gas::Array{Float64, 3},RayCountTotal::Float64)","category":"page"},{"location":"code/#Main.RayTraceHeatTransfer.RayTracing.coefs_exchange-Tuple{RayTracingMesh, Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}, Float64}","page":"Code","title":"Main.RayTraceHeatTransfer.RayTracing.coefs_exchange","text":"coefs_exchange(mesh::RayTracingMesh, Wall_absorbX::Array{Float64, 3},\n                    Wall_absorbY::Array{Float64, 3},\n                    N_abs_gas::Array{Float64, 3},RayCountTotal::Float64)\n\nThis function is called internallly during the ray tracing. After ray tracing one emitter (surface or volume) this function calculates one row of the two corresponding exchange factor matrices.\n\n\n\n\n\n","category":"method"},{"location":"code/","page":"Code","title":"Code","text":"RayTracing.distToSurface(point::SVector{2,Float64}, i1::SVector{2,Float64},\n                    mesh::RayTracingMesh, N_subs_count::Int64)","category":"page"},{"location":"code/#Main.RayTraceHeatTransfer.RayTracing.distToSurface-Tuple{SVector{2, Float64}, SVector{2, Float64}, RayTracingMesh, Int64}","page":"Code","title":"Main.RayTraceHeatTransfer.RayTracing.distToSurface","text":"distToSurface(point::SVector{2,Float64}, i1::SVector{2,Float64},\n                mesh::RayTracingMesh, N_subs_count::Int64)\n\nThis function determines the distance to a plane (a line in 2D) from a given point along a given direction, as well as the index of the wall (bottom, right, top, left).\n\n\n\n\n\n","category":"method"},{"location":"code/","page":"Code","title":"Code","text":"RayTracing.isotropicScatter()","category":"page"},{"location":"code/#Main.RayTraceHeatTransfer.RayTracing.isotropicScatter-Tuple{}","page":"Code","title":"Main.RayTraceHeatTransfer.RayTracing.isotropicScatter","text":"isotropicScatter()\n\nThis function generates a uniformly distributed random sample of a direction in 3D and projects it onto the 2D plane.\n\n\n\n\n\n","category":"method"},{"location":"code/","page":"Code","title":"Code","text":"RayTracing.lambertSample3D()","category":"page"},{"location":"code/#Main.RayTraceHeatTransfer.RayTracing.lambertSample3D-Tuple{}","page":"Code","title":"Main.RayTraceHeatTransfer.RayTracing.lambertSample3D","text":"lambertSample3D()\n\nThis function generates a local diffuse (Lambertian) emission sample from a wall. The generated sample is 3D but is converted to 2D by projecting it onto the 2D plane (by setting third component to zero). This sample correspond to the local coordinates of the given wall. It is later rotated to global coordinates.\n\n\n\n\n\n","category":"method"},{"location":"code/","page":"Code","title":"Code","text":"RayTracing.rayTracing_CPU(subNumber::Int64,wallNumber::Int64,\n                        sampleLeftRight::Bool,sampleTopBottom::Bool,\n                        mesh::RayTracingMesh, gas::GasProperties, N_rays::Int64,\n                        wallEmission::Bool,volumeEmission::Bool,\n                        displayWhileTracing::Bool,nthreads::Int64,\n                        xCountSample::Int64, yCountSample::Int64)","category":"page"},{"location":"code/#Main.RayTraceHeatTransfer.RayTracing.rayTracing_CPU-Tuple{Int64, Int64, Bool, Bool, RayTracingMesh, GasProperties, Int64, Bool, Bool, Bool, Int64, Int64, Int64}","page":"Code","title":"Main.RayTraceHeatTransfer.RayTracing.rayTracing_CPU","text":"rayTracing_CPU(subNumber::Int64,wallNumber::Int64,\n                    sampleLeftRight::Bool,sampleTopBottom::Bool,\n                    mesh::RayTracingMesh, gas::GasProperties, N_rays::Int64,\n                    wallEmission::Bool,volumeEmission::Bool,\n                    displayWhileTracing::Bool,nthreads::Int64,\n                    xCountSample::Int64, yCountSample::Int64)\n\nThis function ray traces a single ray in a 2D domain (or a number of rays in parallel). The ray (or rays) is emitted from a specified emitter (wall or volume) and traced throughout the domain. This function also gives the user the possibility to plot the traced ray paths (must execute single threaded). When all the rays have been traced the absorbed rays are summed up for each cell and returned for use in the calculation of the exchange factor matrices. The ray tracing is performed on a coarse grid and absorption points are mapped to a fine grid. This approach greatly improves the efficiency as opposed to tracing on a fine grid.\n\n\n\n\n\n","category":"method"},{"location":"code/","page":"Code","title":"Code","text":"RayTracing.sampleSurface(mesh::RayTracingMesh, subNumber::Int64, wallNumber::Int64,\n                            xCountSample::Int64, yCountSample::Int64,\n                            sampleLeftRight::Bool, sampleTopBottom::Bool)","category":"page"},{"location":"code/#Main.RayTraceHeatTransfer.RayTracing.sampleSurface-Tuple{RayTracingMesh, Int64, Int64, Int64, Int64, Bool, Bool}","page":"Code","title":"Main.RayTraceHeatTransfer.RayTracing.sampleSurface","text":"sampleSurface(mesh::RayTracingMesh, subNumber::Int64, wallNumber::Int64,\n                        xCountSample::Int64, yCountSample::Int64,\n                        sampleLeftRight::Bool, sampleTopBottom::Bool)\n\nThis function samples an emission position on a 2D surface (a line) as well as an emission direction, given the endpoints of the line and position in the mesh. The function samples from a diffuse (Lambertian) distribution and rotates the sample from local to global coordinates using a rotation matrix.\n\n\n\n\n\n","category":"method"},{"location":"code/","page":"Code","title":"Code","text":"RayTracing.sampleSurfaces(mesh::RayTracingMesh,gas::GasProperties,\n                    N_rays::Int64,nthreads::Int64,displayWhileTracing::Bool)","category":"page"},{"location":"code/#Main.RayTraceHeatTransfer.RayTracing.sampleSurfaces-Tuple{RayTracingMesh, GasProperties, Int64, Int64, Bool}","page":"Code","title":"Main.RayTraceHeatTransfer.RayTracing.sampleSurfaces","text":"sampleSurfaces(mesh::RayTracingMesh,gas::GasProperties,\n                N_rays::Int64,nthreads::Int64,displayWhileTracing::Bool)\n\nThis function samples all of the surface emitters. Each sampled emitter generates rows in the FSS and FSG exchange factor matrices.                \n\n\n\n\n\n","category":"method"},{"location":"code/","page":"Code","title":"Code","text":"RayTracing.sampleVolume(mesh::RayTracingMesh, xCount::Int64, yCount::Int64)","category":"page"},{"location":"code/#Main.RayTraceHeatTransfer.RayTracing.sampleVolume-Tuple{RayTracingMesh, Int64, Int64}","page":"Code","title":"Main.RayTraceHeatTransfer.RayTracing.sampleVolume","text":"sampleVolume(mesh::RayTracingMesh, xCount::Int64, yCount::Int64)\n\nThis function samples an emission point and direction in a volume (a surface in 2D), by separating it in two triangles and sampling according to their area. This operation requires knowledge of the mesh, which is why the mesh is also an input.\n\n\n\n\n\n","category":"method"},{"location":"code/","page":"Code","title":"Code","text":"RayTracing.sampleVolumes(mesh::RayTracingMesh,gas::GasProperties,\n                    N_rays::Int64,nthreads::Int64,displayWhileTracing::Bool)","category":"page"},{"location":"code/#Main.RayTraceHeatTransfer.RayTracing.sampleVolumes-Tuple{RayTracingMesh, GasProperties, Int64, Int64, Bool}","page":"Code","title":"Main.RayTraceHeatTransfer.RayTracing.sampleVolumes","text":"sampleVolumes(mesh::RayTracingMesh,gas::GasProperties,\n                N_rays::Int64,nthreads::Int64,displayWhileTracing::Bool)\n\nThis function samples all of the volumetric (gas) emitters. Each sampled emitter generates rows in the FGS and FGG exchange factor matrices.\n\n\n\n\n\n","category":"method"},{"location":"code/","page":"Code","title":"Code","text":"RayTracing.solidWalls(mesh::RayTracingMesh, N_subs_count::Int64)","category":"page"},{"location":"code/#Main.RayTraceHeatTransfer.RayTracing.solidWalls-Tuple{RayTracingMesh, Int64}","page":"Code","title":"Main.RayTraceHeatTransfer.RayTracing.solidWalls","text":"solidWalls(mesh::RayTracingMesh, N_subs_count::Int64)\n\nThis function finds out if any boundaries are not allowed to be crossed. If we hit these real walls the ray is absorbed or reflected.\n\n\n\n\n\n","category":"method"},{"location":"code/","page":"Code","title":"Code","text":"RayTracing.whichCell(point::SVector{2,Float64},mesh::RayTracingMesh)","category":"page"},{"location":"code/#Main.RayTraceHeatTransfer.RayTracing.whichCell-Tuple{SVector{2, Float64}, RayTracingMesh}","page":"Code","title":"Main.RayTraceHeatTransfer.RayTracing.whichCell","text":"whichCell(point::SVector{2,Float64},mesh::RayTracingMesh)\n\nThis function finds out which cell the ray is currently in.\n\n\n\n\n\n","category":"method"},{"location":"code/","page":"Code","title":"Code","text":"RayTracing.whichSubEnclosure(point::SVector{2,Float64},mesh::RayTracingMesh)","category":"page"},{"location":"code/#Main.RayTraceHeatTransfer.RayTracing.whichSubEnclosure-Tuple{SVector{2, Float64}, RayTracingMesh}","page":"Code","title":"Main.RayTraceHeatTransfer.RayTracing.whichSubEnclosure","text":"whichSubEnclosure(point::SVector{2,Float64},mesh::RayTracingMesh)\n\nThis function finds out which SubEnclosure the ray is currently in.\n\n\n\n\n\n","category":"method"},{"location":"code/#Private-functions-for-view-factor-function","page":"Code","title":"Private functions for view factor function","text":"","category":"section"},{"location":"code/","page":"Code","title":"Code","text":"ViewFactor3D.Cl(theta::Float64, almostZero::Float64)","category":"page"},{"location":"code/#Main.RayTraceHeatTransfer.ViewFactor3D.Cl-Tuple{Float64, Float64}","page":"Code","title":"Main.RayTraceHeatTransfer.ViewFactor3D.Cl","text":"Cl(theta::Float64, almostZero::Float64)\n\nEq.(26) from the paper.\n\n\n\n\n\n","category":"method"},{"location":"code/","page":"Code","title":"Code","text":"ViewFactor3D.edgePairParameters(Po::Matrix{Float64}, Pf::Matrix{Float64},\n                        Qo::Matrix{Float64}, Qf::Matrix{Float64},\n                        almostZero::Float64)","category":"page"},{"location":"code/#Main.RayTraceHeatTransfer.ViewFactor3D.edgePairParameters-Tuple{Matrix{Float64}, Matrix{Float64}, Matrix{Float64}, Matrix{Float64}, Float64}","page":"Code","title":"Main.RayTraceHeatTransfer.ViewFactor3D.edgePairParameters","text":"edgePairParameters(Po::Matrix{Float64}, Pf::Matrix{Float64},\n                    Qo::Matrix{Float64}, Qf::Matrix{Float64},\n                    almostZero::Float64)\n\nhttp://geomalgorithms.com/a07-_distance.html find shortest distance D between line Po+su and Qo+tv for initial  points Po and Qo, parameters s and t, and vectors u and v.\n\n\n\n\n\n","category":"method"},{"location":"code/","page":"Code","title":"Code","text":"ViewFactor3D.f(s::Float64, l::Float64, alpha::Float64,\n        cosAlpha::Float64, sinAlpha::Float64,\n        d::Float64, almostZero::Float64)","category":"page"},{"location":"code/#Main.RayTraceHeatTransfer.ViewFactor3D.f-NTuple{7, Float64}","page":"Code","title":"Main.RayTraceHeatTransfer.ViewFactor3D.f","text":"f(s::Float64, l::Float64, alpha::Float64,\n    cosAlpha::Float64, sinAlpha::Float64,\n    d::Float64, almostZero::Float64)\n\nEq.(22b) from the paper.\n\n\n\n\n\n","category":"method"},{"location":"code/","page":"Code","title":"Code","text":"ViewFactor3D.fParallel(s::Float64, l::Float64,\n            d::Float64, almostZero::Float64)","category":"page"},{"location":"code/#Main.RayTraceHeatTransfer.ViewFactor3D.fParallel-NTuple{4, Float64}","page":"Code","title":"Main.RayTraceHeatTransfer.ViewFactor3D.fParallel","text":"fParallel(s::Float64, l::Float64,\n        d::Float64, almostZero::Float64)\n\nEq.(23) from the paper\n\n\n\n\n\n","category":"method"},{"location":"code/","page":"Code","title":"Code","text":"ViewFactor3D.imagLi_2(mag::Float64, angle::Float64,\n                    almostZero::Float64)","category":"page"},{"location":"code/#Main.RayTraceHeatTransfer.ViewFactor3D.imagLi_2-Tuple{Float64, Float64, Float64}","page":"Code","title":"Main.RayTraceHeatTransfer.ViewFactor3D.imagLi_2","text":"imagLi_2(mag::Float64, angle::Float64,\n                almostZero::Float64)\n\nEq.(24) from the paper.\n\n\n\n\n\n","category":"method"},{"location":"code/#Index","page":"Code","title":"Index","text":"","category":"section"},{"location":"code/","page":"Code","title":"Code","text":"","category":"page"},{"location":"validation/#Code-validation","page":"Code Validation","title":"Code validation","text":"","category":"section"},{"location":"validation/","page":"Code Validation","title":"Code Validation","text":"This section will compare results generated by this package with an analytical solution in order to validate the correctness of the code. This section essentially goes through all of the steps performed by the function \"validCrosbieSchrenker\". We start by loading the package.","category":"page"},{"location":"validation/","page":"Code Validation","title":"Code Validation","text":"using RayTraceHeatTransfer","category":"page"},{"location":"validation/","page":"Code Validation","title":"Code Validation","text":"The geometry is built by a number of non-overlapping sub-enclosures. The sub-enclosures are specified like this so that the meshing and ray tracing can be done in a general way. Here we define a 1x1 square (a single sub-enclosure).","category":"page"},{"location":"validation/","page":"Code Validation","title":"Code Validation","text":"# now we need to know the Coordinates of all the points in the enclosure\n# define a vector of SubEnclosures\nsubs = SubEnclosure[]\n\n# make a SubEnclosure and push it into the vector\nsub1 = SubEnclosure([0.0, 0.0],[1.0, 0.0],[1.0, 1.0],[0.0, 1.0],true,true,true,true)\npush!(subs, sub1)","category":"page"},{"location":"validation/","page":"Code Validation","title":"Code Validation","text":"Now that our bounding geometry has been defined, it is time to mesh it. We mesh it by specifying the number of splits in the x- and y-direction. Then we generate the meshing automatically and plot it.","category":"page"},{"location":"validation/","page":"Code Validation","title":"Code Validation","text":"# generate mesh\nNdim = 51\nmesh1 = RayTracingMesh(subs,Ndim);\n# plot the geometry\ndisplayMesh(mesh1)","category":"page"},{"location":"validation/","page":"Code Validation","title":"Code Validation","text":"Viewing the result:","category":"page"},{"location":"validation/","page":"Code Validation","title":"Code Validation","text":"(Image: plot)","category":"page"},{"location":"validation/","page":"Code Validation","title":"Code Validation","text":"Now our geometry is defined by the 'mesh1' struct.","category":"page"},{"location":"validation/#Monte-Carlo-ray-tracing","page":"Code Validation","title":"Monte Carlo ray tracing","text":"","category":"section"},{"location":"validation/","page":"Code Validation","title":"Code Validation","text":"Now that our geometry is in place, it is time to ray trace the domain. First we define the properties of our participating medium and store them in 'gas1':","category":"page"},{"location":"validation/","page":"Code Validation","title":"Code Validation","text":"sigma_s = 0.0 # scattering coefficient\nkappa = 1.0 # absorption coefficient\ngas1 = GasProperties(sigma_s,kappa)","category":"page"},{"location":"validation/","page":"Code Validation","title":"Code Validation","text":"Then we ray trace and save the results in exchange factor matrices:","category":"page"},{"location":"validation/","page":"Code Validation","title":"Code Validation","text":"displayWhileTracing = false # option to view the rays while they are traced (warning: very demanding)\nN_rays_tot = 10_000_000; # total number of rays\n# number of rays to trace from each zone\nN_rays = trunc(Int, N_rays_tot/(mesh1.N_surfs+mesh1.N_vols))\n\n# We execute the calculation in parallel on all available threads\nnthreads = Threads.nthreads()\n\n# then we ray trace the domain to get the exchange factor matrices\nFSS, FSG, FGS, FGG = sampleDomain(mesh1,gas1,N_rays,nthreads,displayWhileTracing)","category":"page"},{"location":"validation/#Solve-heat-transfer-problem-for-steady-state-temperature-distribution","page":"Code Validation","title":"Solve heat transfer problem for steady state temperature distribution","text":"","category":"section"},{"location":"validation/","page":"Code Validation","title":"Code Validation","text":"Now it is time to solve heat transfer problems on the domain defined by our geometry. First we fix the wall temperatures and set the initial gas temperatures. Then we solve for the steady state.","category":"page"},{"location":"validation/","page":"Code Validation","title":"Code Validation","text":"# define boundary conditions\n\n# define which wall temperatures are fixed\n# we only need to set those which should be fixed\n# those which are set to negative will be interpreted as unknown\nTw_hot = 1000.0\nqw_in = zeros(mesh1.N_subs,4)\n\n# set the emissivities\nepsw_in = ones(mesh1.N_subs,4)\n\n# gas initial temperatures, set temperatures on a sub enclosure basis\nTg_in = zeros(mesh1.N_subs) .- 1 # unknown gas temperature\nqg_in = zeros(mesh1.N_subs) # radiative equilibrium\n\n# test bottom wall emissions\nTw_in = zeros(mesh1.N_subs,4)\nTw_in[1,1] = Tw_hot # bottom wall\nprintln(\"Calculating steady state temperature distribution (bottom wall emitter).\")\nTw, Tg, qw, qg = steadyState(mesh1,FSS,FSG,FGS,FGG,\n                            epsw_in,gas1,Tw_in,Tg_in,qw_in,qg_in);","category":"page"},{"location":"validation/","page":"Code Validation","title":"Code Validation","text":"Now let's rearrange our gas volume temperature vector into the square of squares that it represents and plot them all:","category":"page"},{"location":"validation/","page":"Code Validation","title":"Code Validation","text":"Tg_matrix = plotTemperatureField(mesh1,Tg) #,Tw); # optional wall temperatures","category":"page"},{"location":"validation/","page":"Code Validation","title":"Code Validation","text":"Giving:","category":"page"},{"location":"validation/","page":"Code Validation","title":"Code Validation","text":"(Image: plot)","category":"page"},{"location":"validation/","page":"Code Validation","title":"Code Validation","text":"As the last step, we also validate the code against the analytical solution of Crosbie and Schrenker (1982). Plotting the (Tg/Tw)^4 for the centerline perpendicular to the incident radiation and comparing it to the analytical solution gives:","category":"page"},{"location":"validation/","page":"Code Validation","title":"Code Validation","text":"(Image: plot)","category":"page"},{"location":"validation/","page":"Code Validation","title":"Code Validation","text":"Which is not perfect, but still quite close considering that we only traced 10 million rays in total. Increasing the number of rays to 1 billion and repeating gives:","category":"page"},{"location":"validation/","page":"Code Validation","title":"Code Validation","text":"(Image: plot)","category":"page"},{"location":"validation/","page":"Code Validation","title":"Code Validation","text":"(Image: plot)","category":"page"},{"location":"validation/","page":"Code Validation","title":"Code Validation","text":"Decreasing the number of subdivisions (Ndim) would further increase the accuracy.","category":"page"},{"location":"heattransfer/#Calculate-heat-transfer","page":"Calculate heat transfer","title":"Calculate heat transfer","text":"","category":"section"},{"location":"heattransfer/","page":"Calculate heat transfer","title":"Calculate heat transfer","text":"In this section we will solve a radiation heat transfer problem using the geometry which was generated and sampled in the previous sections. The most important thing when solving radiation heat transfer problems is to correctly define all of the boundary conditions and known information. The properties of the participating medium was specified before the ray tracing so this is already fixed. The remaining properties which need to be fixed are:","category":"page"},{"location":"heattransfer/","page":"Calculate heat transfer","title":"Calculate heat transfer","text":"Emissivities of all solid walls\nA temperature or a heat source term for each element","category":"page"},{"location":"heattransfer/","page":"Calculate heat transfer","title":"Calculate heat transfer","text":"First we set the emissivities. Here we set all the solid walls of all four subEnclosures to have an emissivity of one. The row number is the subenclosure number (in the order they were added).","category":"page"},{"location":"heattransfer/","page":"Calculate heat transfer","title":"Calculate heat transfer","text":"epsw_in = zeros(mesh1.N_subs,4)\nepsw_in[1,mesh1.solidWalls[1]] .= 1.0\nepsw_in[2,mesh1.solidWalls[2]] .= 1.0\nepsw_in[3,mesh1.solidWalls[3]] .= 1.0\nepsw_in[4,mesh1.solidWalls[4]] .= 1.0","category":"page"},{"location":"heattransfer/","page":"Calculate heat transfer","title":"Calculate heat transfer","text":"Next, we define the fixed temperatures and source terms. We start by specifying the walls. We will set a hot wall temperature of 1000.0 Kelvin at the lower subenclosure and leave the remaining walls at 0.0 Kelvin (no emission). This means all wall temperatures will be known and the result of the calculation will be the heat source (or sink) term of the walls in Watts. When the temperature is specified as non-negative, this is the one which will be used. If the temperature is specified as negative, then the source term will be used. In any case the source term must be specified (to ensure consistent inputs), but it is only used if the temperature is set to negative.","category":"page"},{"location":"heattransfer/","page":"Calculate heat transfer","title":"Calculate heat transfer","text":"Tw_hot = 1000.0\nTw_in = zeros(mesh1.N_subs,4)\nqw_in = zeros(mesh1.N_subs,4)\nTw_in[1,mesh1.solidWalls[1]] .= Tw_hot\nTw_in[2,mesh1.solidWalls[2]] .= 0.0\nqw_in[3,mesh1.solidWalls[3]] .= 0.0\nqw_in[4,mesh1.solidWalls[4]] .= 0.0","category":"page"},{"location":"heattransfer/","page":"Calculate heat transfer","title":"Calculate heat transfer","text":"Next, the same must be repeated for the gas volumes. The gas volume known information is specified on a subenclosure basis but the results will be returned at full cell-level mesh resolution. We set the temperature of the gas volumes to be unknown by specifying a negative temperature. The source terms are all set to zero, corresponding to 'radiative equilibrium', meaning that no other modes of heat transfer are present.","category":"page"},{"location":"heattransfer/","page":"Calculate heat transfer","title":"Calculate heat transfer","text":"Tg_in = zeros(mesh1.N_subs) .- 1\nqg_in = zeros(mesh1.N_subs)","category":"page"},{"location":"heattransfer/","page":"Calculate heat transfer","title":"Calculate heat transfer","text":"Now we are ready to solve the heat transfer problem! We will use the function 'steadyState' to calculate the equilibrium temperatures and source terms.","category":"page"},{"location":"heattransfer/","page":"Calculate heat transfer","title":"Calculate heat transfer","text":"@time begin\nTw, Tg, qw, qg = steadyState(mesh1,FSS,FSG,FGS,FGG, \n                                epsw_in,gas1,\n                                Tw_in,Tg_in,qw_in,qg_in);\nend","category":"page"},{"location":"heattransfer/","page":"Calculate heat transfer","title":"Calculate heat transfer","text":"And lastly, let's plot the temperature field. This function takes the mesh and the temperature vectors as input (the wall temperatures are optional). Apart from the plot it also returns the gas temperatures in the form of an array:","category":"page"},{"location":"heattransfer/","page":"Calculate heat transfer","title":"Calculate heat transfer","text":"The first dimension of the Tg_array are the subenclosures.\nThe next dimensions are the x- and y-splits of each subenclosure.","category":"page"},{"location":"heattransfer/","page":"Calculate heat transfer","title":"Calculate heat transfer","text":"Tg_array = plotTemperatureField(mesh1,Tg) #,Tw); # optional wall temperatures","category":"page"},{"location":"heattransfer/","page":"Calculate heat transfer","title":"Calculate heat transfer","text":"Even though there is no flow in the domain and the gas is strongly cooled be the cold walls the radiation from the hot wall heats the entire domain due to the absorption and reradiation in the gas.","category":"page"},{"location":"heattransfer/","page":"Calculate heat transfer","title":"Calculate heat transfer","text":"(Image: plot)","category":"page"},{"location":"#RayTraceHeatTransfer.jl-Documentation","page":"Home","title":"RayTraceHeatTransfer.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Radiative heat transfer in participating media","category":"page"},{"location":"#Description","page":"Home","title":"Description","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This Julia package can be used for radiation heat transfer calculations in an enclosure with partly or fully reflecting walls containing an absorbing-emitting-scattering participating medium. This phenomenon is governed by the Radiative Transfer Equation (RTE), which is a integro-differential equation:","category":"page"},{"location":"","page":"Home","title":"Home","text":"fracpartial I_lambda(SOmega)partial S = kappa_lambda I_lambda mathrmb(S) - kappa_lambda I_lambda(SOmega) - sigma_mathrmslambda I_lambda(SOmega) + fracsigma_mathrmslambda4 pi int_Omega_i=4 pi I_lambda(SOmega_i) Phi_lambda(Omega_iOmega) dOmega_i","category":"page"},{"location":"","page":"Home","title":"Home","text":"Analytical solution of the RTE is only possible in simple cases. This repository contains a number of types and functions which collectively enables the user to build, mesh and ray trace a user defined 2D geometry to solve the RTE. The result of the ray tracing is four 'Exchange Factor' matrices which together describe how the enclosure is radiatively connected. Using the exchange factor matrices it is possible to quickly perform a heat transfer calculation on the entire enclosure, which would otherwise be computationally expensive to ray trace.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Define a custom 2D geometry in a modular and interactive way.\nMesh the user defined geometry.\nRay trace the meshed geometry in parallel.\nSave and load ray tracing results as Exchange Factor matrices in CSV-format.\nQuickly calculate heat transfer in the geometry using the Exchange Factors.\nAvoid ray tracing the same geometry multiple times when changing boundary conditions.","category":"page"},{"location":"#Limitations","page":"Home","title":"Limitations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is limited to:","category":"page"},{"location":"","page":"Home","title":"Home","text":"A uniformly distributed gray participating medium.\nDiffuse surface emission/reflection.","category":"page"},{"location":"raytracing/#Ray-trace-the-geometry","page":"Ray trace the geometry","title":"Ray trace the geometry","text":"","category":"section"},{"location":"raytracing/","page":"Ray trace the geometry","title":"Ray trace the geometry","text":"In the previous section the geometry was created. Now it is time to sample the geometry. This package works by sampling every element of the entire geometry a specified number of times. This sampling process generates 'exchange factor' matrices. The exchange factors describe the connectivity of the domain. This connectivity depends on the properties of the participating medium (the enclosed gas).","category":"page"},{"location":"raytracing/","page":"Ray trace the geometry","title":"Ray trace the geometry","text":"The first thing we need to do is to specify the properties of the participating medium. This is done by speciying the scattering coefficient and the absorption coefficient and generating an instance of the GasProperties type.","category":"page"},{"location":"raytracing/","page":"Ray trace the geometry","title":"Ray trace the geometry","text":"sigma_s = 0.0 # scattering coefficient\nkappa = 1.0 # absorption coefficient\ngas1 = GasProperties(sigma_s,kappa)","category":"page"},{"location":"raytracing/","page":"Ray trace the geometry","title":"Ray trace the geometry","text":"Then we specify the total number of rays that should be traced in the domain. More rays give a more accurate result but is also more computationally demanding. Here we choose 10 million rays.","category":"page"},{"location":"raytracing/","page":"Ray trace the geometry","title":"Ray trace the geometry","text":"N_rays_tot = 10_000_000","category":"page"},{"location":"raytracing/","page":"Ray trace the geometry","title":"Ray trace the geometry","text":"Then we divide these rays among the total number of elements in the domain","category":"page"},{"location":"raytracing/","page":"Ray trace the geometry","title":"Ray trace the geometry","text":"N_rays = trunc(Int, N_rays_tot/(mesh1.N_vols+mesh1.N_surfs))","category":"page"},{"location":"raytracing/","page":"Ray trace the geometry","title":"Ray trace the geometry","text":"The sampling process gives the user the option of viewing the ray tracing 'live' as it takes place. This option is however very computationally demanding and must execute single threaded. Therefore, if enabling this option, only a few rays should be sampled from each emitter. But we will leave this option turned off.","category":"page"},{"location":"raytracing/","page":"Ray trace the geometry","title":"Ray trace the geometry","text":"displayWhileTracing = false","category":"page"},{"location":"raytracing/","page":"Ray trace the geometry","title":"Ray trace the geometry","text":"Next we make the calculation run in parallel on all available threads. This is done to accelerate the ray tracing. The ray tracing can run in parallel on any number of threads.","category":"page"},{"location":"raytracing/","page":"Ray trace the geometry","title":"Ray trace the geometry","text":"if displayWhileTracing\n    nthreads = 1\nelse\n    nthreads = Threads.nthreads()\nend","category":"page"},{"location":"raytracing/","page":"Ray trace the geometry","title":"Ray trace the geometry","text":"Lastly we sample the domain and time the entire process. This sampling process generates the exchange factor matrices. The sampling function prints its progress to the Julia REPL.","category":"page"},{"location":"raytracing/","page":"Ray trace the geometry","title":"Ray trace the geometry","text":"@time begin\n    println(\"Starting ray tracing of $N_rays_tot ray bundles in total ($N_rays per emitter):\")\n    FSS, FSG, FGS, FGG = sampleDomain(mesh1,gas1,N_rays,nthreads,displayWhileTracing)\n    println(\"Ray tracing finished, the total time elapsed was:\")\nend;","category":"page"},{"location":"raytracing/","page":"Ray trace the geometry","title":"Ray trace the geometry","text":"Now that the domain has been sampled and the exchange factors has been statistically measured the next step is to solve heat transfer problems.","category":"page"},{"location":"viewfactor/#View-Factors-in-3D","page":"View Factors in 3D","title":"View Factors in 3D","text":"","category":"section"},{"location":"viewfactor/","page":"View Factors in 3D","title":"View Factors in 3D","text":"As a utility functionality this repository also features a function to calculate view factors between arbitrary polygons separated by a fully transparent medium. It is the long term intention to make RayTraceHeatTransfer.jl into a 3D ray tracing code and by then the 3D view factor function will be valuable for validation.","category":"page"},{"location":"viewfactor/","page":"View Factors in 3D","title":"View Factors in 3D","text":"The original authors of the MATLAB-implementation of this function are: Jacob A. Kerkhoff and Michael J. Wagner of University of Wisconsin-Madison, Energy Systems Optimization Lab. The MATLAB implementation is available at the following repository: https://github.com/uw-esolab/docs/tree/main/tools/viewfactor . This function was originally written for the paper: \"A Flexible Thermal Model for Solar Cavity Receivers Using Analytical View Factors\" https://doi.org/10.1115/ES2021-63810 .","category":"page"},{"location":"viewfactor/","page":"View Factors in 3D","title":"View Factors in 3D","text":"The function was translated to the Julia programming language by the author of RayTraceHeatTransfer.jl during studies at Aalborg University, Thermal Energy and Process Engineering. The ray tracing part of the original function was not translated. Published in RayTraceHeatTransfer.jl with permission from the original authors.","category":"page"},{"location":"viewfactor/","page":"View Factors in 3D","title":"View Factors in 3D","text":"The analytical solution was derived in the following paper: Narayanaswamy, Arvind. \"An analytic expression for radiation view factor between two arbitrarily oriented planar polygons.\" International Journal of Heat and Mass Transfer 91 (2015): 841-847 https://doi.org/10.1016/j.ijheatmasstransfer.2015.07.131 .","category":"page"},{"location":"viewfactor/","page":"View Factors in 3D","title":"View Factors in 3D","text":"viewFactor(POLYA, POLYB) analytically computes the view factor from POLYA to POLYB and from POLYB to POLYA. Input arguments are in the form of 3x2 or Nx3 arrays, where each row corresponds to a vertex of the polygon, the columns refer to the X,Y,Z coordinates of the vertices. If Z coordinates are omitted, they are assumed to be zero.","category":"page"},{"location":"viewfactor/","page":"View Factors in 3D","title":"View Factors in 3D","text":"The following must be true for both polygons:","category":"page"},{"location":"viewfactor/","page":"View Factors in 3D","title":"View Factors in 3D","text":"polygons are planar (all vertices lie in the same plane)\npolygons are simple (no self-intersecting polygons)\npolygons are convex (in theory, concave polygons should work, but  this remains untested)","category":"page"},{"location":"viewfactor/","page":"View Factors in 3D","title":"View Factors in 3D","text":"Below an example is given:","category":"page"},{"location":"viewfactor/","page":"View Factors in 3D","title":"View Factors in 3D","text":"POLY_A = [0.0 0.0 0.0\n        1.0 0.0 0.0\n        1.0 1.0 0.0\n        0.0 1.0 0.0]\nPOLY_B = [0.0 0.0 1.0\n        1.0 0.0 1.0\n        1.0 1.0 1.0\n        0.0 1.0 1.0]\nresultPaper = 0.199825\nF_AB, F_BA, area_A, area_B = viewFactor(POLY_A, POLY_B)","category":"page"}]
}
